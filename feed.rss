<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>finestructure</title><description>An independent software development company</description><link>https://finestructure.co</link><language>en</language><lastBuildDate>Mon, 30 Mar 2020 17:45:21 +0200</lastBuildDate><pubDate>Mon, 30 Mar 2020 17:45:21 +0200</pubDate><ttl>250</ttl><atom:link href="https://finestructure.co/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://finestructure.co/posts/state-of-the-app</guid><title>State of the App: State Surfing</title><description>Browse your app‚Äôs state history like a git repository</description><link>https://finestructure.co/posts/state-of-the-app</link><pubDate>Mon, 30 Mar 2020 09:41:00 +0200</pubDate><content:encoded><![CDATA[<h1>State of the App: State Surfing</h1><p>Imagine you could scroll through your app states like your browsing history.</p><p>What if the actions you take via the user interface were visible like a Git graph and you could jump around between revisions?</p><p>Or how about exporting any state into a file and re-applying it at a later time?</p><p>These are things I‚Äôve always wanted to be able to do while developing an app and it is now possible, with <a href="https://github.com/finestructure/Historian">Historian</a> and Composable Architecture, an application architecture <a href="https://www.twitter.com/mbrandonw">Brandon Williams</a> and <a href="https://www.twitter.com/stephencelis">Stephen Celis</a> are developing in their video series over <a href="https://www.pointfree.co/collections/composable-architecture">at Pointfree.co</a>.</p><p>Have a look at it in action:</p><div class="wrapper"><iframe src="https://player.vimeo.com/video/402216905" width="640" height="332" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div><h2>Composable Architecture</h2><p>I‚Äôve largely ignored the app architecture ‚Äúscene‚Äù, because it mostly seems to be about MVC variants or geared towards apps of massive scale that I have little opportunity to be involved with. I get why they exists and they probably solve tricky problems at scale but for what I do, MVC with sensible composition was fine.</p><p>Despite this, though, I have recently transitioned an app prototype over to Composable Architecture, and I feel it is of enormous value for app development.</p><p>It‚Äôs not just that it enables history browsing. There are other significant advantages to adopting Composable Architecture, which make it a very compelling choice. I will get to that in a moment but first let‚Äôs look at what Composable Architecture actually is.</p><h2>State, Action, Reducer</h2><p>Since <a href="https://pointfree.co">Pointfree.co</a> is a subscription service and not everyone reading this post will be a subscriber (you should subscribe though, what are you doing) I will briefly recap what it entails. While Pointfree.co‚Äôs material will help you understand the architecture much better than I could ever do it justice, everything I talk about and show is available as open source, and ready to be included in your own projects.</p><p>At the core of ‚ÄúComposable Architecture‚Äù rests the following mechanism:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/CA-state-diagram.png" width="720"/><p>Your app‚Äôs entire state is represented by a <code>struct</code> we‚Äôll call <code>State</code> and which is kept in a <code>Store</code>. In order to change values in this <code>struct</code> you send <code>Action</code>s to the <code>Store</code>, defined in an <code>enum Action</code>. These actions are applied to the <code>struct</code> via a <code>Reducer</code> function, which is essentially a function of shape <code>(inout State, Action) -&gt; [Effect&lt;Action&gt;]</code>.</p><p>The <code>[Effect&lt;Action&gt;]</code> array deals with an aspect that often complicates app development: side effects. They encapsulate everything and anything you might want to do that does not directly apply to your <code>State</code>, for instance:</p><ul><li>file system reads/writes</li><li>network requests</li><li>notifications</li></ul><p>These actions will either be ‚Äúfire and forget‚Äù, i.e. <code>() -&gt; Void</code>, or send a new action to your <code>Store</code>, <code>() -&gt; Action</code></p><p>This may seem quite abstract but you can explore all the details in an <a href="https://github.com/finestructure/PFCompArch">example app called PFCompArch</a> using an implementation of the <a href="https://github.com/finestructure/CompArch">Composable Architecture library</a>. Note that Pointfree.co have pretty much confirmed that they will come out with an official release of their architecture, um, <a href="https://twitter.com/pointfreeco/status/1233577564225957888">someday</a> üòÖ. In the meantime, the above will get you started.</p><p>There are a few very interesting consequences that come with this architecture:</p><ul><li>Your entire app state is represented by a single <code>struct</code>. If this struct is <code>Codable</code> (and that‚Äôs something that is quite feasible and desirable), nothing stops you from recording, archiving, or transmitting this state and inspecting or re-applying it to your application at a later time.</li><li>The stream of your actions gives you a detailed timeline of changes to your app. It is like a git graph for your app state where each action constitutes a diff that is applied to an initial state. Just like you can create a patch file from a commit, you can take an action and apply it to a <code>Store</code>.</li><li>Since the reducer is a pure function and the only way to modify your app‚Äôs state, everything becomes very easily testable. And since you can easily prepare the initial state, it becomes much easier to test intricate scenarios.</li><li>Finally, Composable Architecture, is, well, composable. That means the <code>State</code>, <code>Action</code>s, and <code>Reducer</code> can be broken down into smaller components, just like SwiftUI views, and then recomposed into the entire whole. This makes individual parts of your app their only independent world that you can work on and refine in isolation. In fact, Pointfree.co go so far as to place app sections into their own modules that can be compiled and used ‚Äì in SwiftUI previews or Swift playgrounds ‚Äì entirely on their own.</li></ul><h2>The Reality</h2><p>Now I‚Äôm not going to lie: the reality of applying this fantastic architecture to an app is not entirely trivial. While Brandon and Stephen have done an amazing job of creating their own example app that aims to cover all the essential parts app development touches on, invariably you will come upon areas that are not covered by an example.</p><p>This is where it really helps to have built an intuition and understanding of how the concept works and what tools you have available. I will admit I feel like I'm still in the middle of this process. However, after several months of chipping away at this off and on, I‚Äôve finally managed to transition an app prototype over to the Composable Architecture, and am <em>very</em> happy with the results.</p><p>While my goal initially was to simply have better testing capabilities, something else struck me and it is something I recall Chris Eidhof <a href="https://twitter.com/chriseidhof/status/999994103839580162?s=21">also exploring</a>: creating a history viewer for your app state.</p><h2>Past, Present, and Future</h2><p>Amazingly, once I was done transitioning my app over to the Composable Architecture, it took me well inside a day to add this history viewing capability. Most of the time was actually spent working around some SwiftUI issues and conceptual gaps I still had with the Composable Architecture.</p><p>The result makes me really happy. In fact, inspecting the action stream gave immediate benefits by making obvious some necessary changes to the app‚Äôs actions, breaking them down further into more granular steps.</p><p>Take another look <a href="https://vimeo.com/402216905 "Demo video"">at the video</a> at the beginning of this blog post and note how you can not only observe the actions and move through the states. You can also drag a state snapshot out to the desktop where it is saved as a JSON representation. And later, you can drop it back onto the history viewer to re-apply it. This is persisting your entire app state via drag and drop.</p><p>Imagine how this can facilitate things like</p><ul><li>getting the app back into a state to debug an intricate UI or network issue</li><li>re-instate a nice app view for marketing screenshots</li><li>debug and improve your event stream by observing redundancies or weird action sequences ‚Äì because haven‚Äôt we all seen UI glitches where we wondered what triggered <em>that</em> under the hood</li></ul><h2>Multipeer streaming, a.k.a ‚ÄúState Surfing‚Äù</h2><p>Now, what <em>actually</em> prompted me to explore a history viewer was a thought that occurred to me when I saw Gui Rambos <a href="https://twitter.com/_inside/status/1233733464790372353">announcement of MultipeerKit</a> recently: what if I streamed actions and app state over the network and displayed them?</p><p>Because while I find the initial take to add a history as a window to a macOS app quite nice and useful, that‚Äôs not something that as easily done on iOS. Even if you bring up a debug view inside you app, you‚Äôll be hard pressed to operate it at the same time.</p><p>So how about having a history viewer that receives state messages over the network while your iOS app retains its regular interface and the viewer acts as the extra window?</p><h2>Introducing <a href="https://github.com/finestructure/Historian">Historian</a></h2><p>Thanks to SwiftUI and MultipeerKit‚Äôs support for macOS and iOS, it was surprisingly simple to bring the viewer to both platforms and allow inspection and ‚Äústate surfing‚Äù from whichever device you have available:</p><div class="wrapper"><iframe src="https://player.vimeo.com/video/397601668" width="640" height="570" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div><p>What you see here is the same macOS app as before, except this time its history is being observed and displayed on an iOS device.</p><p>Note that the viewer is entirely generic. It accepts a <code>String</code> description for the action and a <code>Data</code> object holding the app‚Äôs state. Clicking a row sends the <code>Data</code> back to the app, which decodes it and resets its state to what it received.</p><p>As mentioned, the transmitting app doesn‚Äôt have to be a macOS app. You can just as well observe an iOS app with the iOS history viewer. Or observe it with the macOS version ‚Äì either combination works. You can even observe an app from two viewers at the same time.</p><p>I have packaged up the history viewer ‚Äì <a href="https://github.com/finestructure/Historian">Historian</a> ‚Äì and published it on Github. Again, this viewer app is entirely stand-alone and listens on the local network for state broadcasts from an app that is appropriately instrumented to send them.</p><p>We‚Äôll cover those instrumentation steps next.</p><h2>Integrating Historian in your app</h2><p>Adding support for Historian essentially means to set up your app to send its actions as <code>String</code>s and its state as <code>Data</code> at a strategic top level location where all actions and state information is available. You do this by conforming to protocols.</p><p>The biggest hurdle to ‚ÄúState Surfing‚Äù is clearly adopting a whole new app architecture but there are enough great reasons to do this already ‚Äì browsing your app history is just the cherry on top.</p><p>You can head over to <a href="https://www.pointfree.co/collections/composable-architecture">Pointfree.co‚Äôs collection of videos</a> to get started with adopting their Composable Architecture in case you haven‚Äôt done so already.</p><p>The good news is that once you have transitioned your app to the Composable Architecture ‚Äì or if you‚Äôve been using it all along ‚Äì you are almost all the way there to surf your app states already.</p><h2>Step by step</h2><p>Let‚Äôs look at the steps required to add support for Historian to your Composable Architecture app.</p><p>Here‚Äôs an outline of the steps required. In order to establish common nomenclature, I assume that your top level view is a <code>ContentView</code> and that this view‚Äôs state is held in a struct <code>ContentView.State</code> ‚Äì i.e. a <code>struct State</code> declared within <code>ContentView</code>.</p><p>This is a practise I adopted for my Composable Architecture apps and which allows me to refer to the state simply as <code>State</code> when within view context and to use the view as a namespace whenever I refer to it externally. (See <a href="https://twitter.com/_sa_s/status/1239666390312923137">this tweet</a> on how to avoid name collisions with SwiftUI‚Äôs <code>@State</code>.)</p><p>There are only a few steps required to support Historian:</p><ol><li>Add the <code>HistoryTransceiver</code> SPM package as a dependency</li><li>Make your app‚Äôs <code>ContentView.State</code> adopt the <code>StateInitializable</code> protocol</li><li>Make your app‚Äôs <code>ContentView</code> adopt the <code>StateSurfable</code> protocol</li><li>In your <code>SceneDelegate</code> (or <code>AppDelegate</code> for macOS) where you instantiate your <code>ContentView</code> and pass it to the hosting controller, instead instantiate <code>HistoryTransceiverView&lt;ContentView&gt;</code>, and call <code>resume</code> to start broadcasting.</li></ol><p>Let‚Äôs go through the steps, what they entail, and why they‚Äôre required in detail.</p><h2>Adding <code>HistoryTransceiver</code></h2><p>The <code>HistoryTransceiver</code> SPM package brings with it everything that‚Äôs required to start streaming your states and to integrate with Historian. Most importantly, it declares two protocols, <code>StateInitializable</code> and <code>StateSurfable</code> which specify all the required implementation details you need to take care of. The main task is to adopt these two protocols.</p><h2>Adopting <code>StateInitializable</code></h2><p>The first one is simple: <code>StateInitializable</code> essentially specifies the requirements to transmit and instantiate <code>State</code> from <code>Data</code>:</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">StateInitializable</span>: <span class="hljs-title">Codable</span> </span>{
    <span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">init</span>?(from data: <span class="hljs-type">Data</span>)
}
</code></pre><p>Your <code>State</code> needs to be <code>Codable</code> and provide <code>init?(from: data: Data)</code> in order to be streamed and instantiated from received <code>Data</code>.</p><p>The other required initialiser, <code>init()</code>, represents the initial or ‚Äúempty‚Äù state. When users wind back the history all the way to the start, <code>Historian</code> will send a <code>nil</code> data <code>Message</code> as a signal, which in turn will inject a <code>State</code> instantiated from <code>init()</code> into your app. Therefore, you need to implement <code>init()</code> such that it provides your app‚Äôs initial state.</p><h2>Adopting <code>StateSurfable</code></h2><p>The <code>StateSurfable</code> protocol deals with preparing your top level view to be wrapped in a <code>HistoryTranceiverView</code>. This view handles broadcasting state changes and receiving and applying state updates from Historian.</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">StateSurfable</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span>: <span class="hljs-type">StateInitializable</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Action</span>
    <span class="hljs-keyword">var</span> store: <span class="hljs-type">Store</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reducer: <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(store: Store&lt;State, Action&gt;)</span></span> -&gt; <span class="hljs-type">Self</span>
}
</code></pre><p>By implementing the required methods, you are preparing <code>ContentView</code> to be swapped out for <code>HistoryTranceiverView</code></p><p>A typical implementation of this protocol should be as simple as the following:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">StateSurfable</span> </span>{
     <span class="hljs-keyword">typealias</span> <span class="hljs-type">State</span> = <span class="hljs-type">ContentView</span>.<span class="hljs-type">State</span>      <span class="hljs-comment">// redundant, for illustration purposes</span>
     <span class="hljs-keyword">typealias</span> <span class="hljs-type">Action</span> = <span class="hljs-type">ContentView</span>.<span class="hljs-type">Action</span>    <span class="hljs-comment">// redundant, for illustration purposes</span>

     <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(store: Store&lt;State, Action&gt;)</span></span> -&gt; <span class="hljs-type">ContentView</span> {
         <span class="hljs-type">ContentView</span>(store: store)
     }
     <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reducer: <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; {
         <span class="hljs-type">ContentView</span>.reducer                  <span class="hljs-comment">// redundant, for illustration purposes</span>
     }
 }
</code></pre><p>It is essentially a mapping of your types and the reducer function to what <code>HistoryTransceiverView</code> expects and uses to wire everything up.</p><h2>Update your <code>SceneDelegate</code> or <code>AppDelegate</code></h2><p>We‚Äôre almost done now. The final step is to swap out your <code>ContentView</code>. In a typical application this looks as follows. Find and replace</p><pre data-language="swift"><code>window.rootViewController = <span class="hljs-type">UIHostingController</span>(rootView: <span class="hljs-type">ContentView</span>(store: ...))
</code></pre><p>with</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> contentView = <span class="hljs-type">HistoryTransceiverView</span>&lt;<span class="hljs-type">ContentView</span>&gt;()
contentView.resume()
window.rootViewController = <span class="hljs-type">UIHostingController</span>(rootView: contentView) 
</code></pre><p>The call to <code>resume()</code> will set up the transceiver and initiate state broadcasting. If you don‚Äôt want to do this at launch, you can gate this call behind a menu item or some other UI element to turn it on.</p><p>And that‚Äôs it. With these changes in place, you can launch both Historian and your app and whenever actions fire, Historian will receive and display those updates. You can browse the list, step through the updates, and the macOS app even allows you to drag and drop state snapshots from and to Historian.</p><h2>Wrapping up</h2><p>As mentioned above, you can find an <a href="https://github.com/finestructure/PFCompArch">example Composable Architecture application on Github</a> and <a href="https://github.com/finestructure/PFCompArch/pull/6">this Pull Request</a> shows you how to integrate Historian with it.</p><p>If you are following the Pointfree.co series and are familiar with their example app ‚ÄúPrime Time‚Äù, you can find the same integration done for their app in <a href="https://github.com/pointfreeco/episode-code-samples/pull/52">this pull request</a>.</p><p>I hope you find this post useful and would love to see what apps you successfully instrument for ‚ÄúState Surfing‚Äù. Please drop me a line and let me know!</p><p>Follow me <a href="https://twitter.com/_sa_s">on twitter</a> to catch announcements about Historian and State Surfing and please <a href="mailto:sas+blog@finestructure.co">get in touch</a> if you have questions, comments, or suggestions.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://finestructure.co/posts/arena</guid><title>üèü Arena: Explore SPM packages with ease</title><description>Open SPM-packages in a playground straight from Github</description><link>https://finestructure.co/posts/arena</link><pubDate>Tue, 3 Mar 2020 09:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>üèü Arena: Explore SPM packages with ease</h1><p>The Swift Package Manager (SPM) made a big leap forward last summer when it gained Xcode integration. While it was quite feasible to use it for Swift projects before, being able to manage packages via Xcode made it so much easier and removed almost all of the friction when dealing with <code>Package.swift</code> files.</p><p>One area that is still a bit lacking, however, is the ease with which you can bring SPM packages into Swift playgrounds.</p><p>With <a href="https://github.com/finestructure/Arena">Arena</a>, this is now as simple as copying a Github URL. Just run</p><pre data-language="bash"><code>arena https://github.com/finestructure/Gala
</code></pre><p>and Arena will assemble an Xcode workspace with a playground ready to go and explore the package you are interested in trying out. (Find out more about <a href="https://finestructure.squarespace.com/blog/2020/1/28/enhance-your-swiftui-previews-with-gala">Gala here</a>.)</p><p>Perhaps you want to give <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> 5.0 a try before upgrading? Just run</p><pre data-language="bash"><code>arena https://github.com/Alamofire/Alamofire@from:5.0.0
</code></pre><p>and you‚Äôre good to go:</p><div class="wrapper"><iframe src="https://player.vimeo.com/video/394958290" width="640" height="400" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div><p>Playgrounds are a great way to explore Swift and Arena now makes it a breeze to extend that experimentation to SPM packages.</p><p>Try out Swift‚Äôs new <a href="https://github.com/apple/swift-argument-parser">ArgumentParser library</a></p><pre data-language="bash"><code>arena https://github.com/apple/swift-argument-parser
</code></pre><p>or give Dave DeLong‚Äôs <a href="https://github.com/davedelong/time">Time library</a> a spin:</p><pre data-language="bash"><code>arena https://github.com/davedelong/time
</code></pre><p>It‚Äôs dead simple to get going with Arena and playgrounds.</p><p>Arena supports the same version specifications you can use in <code>Package.swift</code> so you can easily pick a particular version, version range, branch, or even revision. Head over to <a href="https://github.com/finestructure/Arena">Arena‚Äôs Github repository</a> to see a <a href="https://github.com/finestructure/Arena#specifying-versions">list of examples</a> (and give it a ‚≠êÔ∏è while you‚Äôre there üôÇ).</p><h2>Create Playground Books for Swift Playgrounds</h2><p>In February, Apple released <a href="https://apps.apple.com/app/swift-playgrounds/id1496833156">Swift Playgrounds for Mac</a> and if you prefer the app over Xcode playgrounds, Arena can create Playground Books which can be imported into Swift Playgrounds.</p><p>And as a bonus, these Playground Books can sync over to your iOS devices where you can continue to work on them.</p><p>This feature is experimental for the moment. It requires that the SPM packages you are trying out support iOS and it does not yet resolve transitive dependencies. However it should allow you to try out many packages using the same playground file on your Mac and iOS device.</p><p>You can create a Playground Book by passing the <code>--book</code> parameter to the <code>arena</code> command:</p><pre data-language="bash"><code>arena https://github.com/finestructure/Gala --book
</code></pre><p>Run</p><pre data-language="bash"><code>open Arena-Playground/Arena-Playground.playgroundbook
</code></pre><p>to open and import the Playground Book. And it works on your iOS device as well:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/arena-gala-on-ipad.png" width="800"/><h2>Install via Homebrew or Mint</h2><p>Arena is easy to install via <a href="https://brew.sh">Homebrew</a></p><pre data-language="bash"><code>brew install finestructure/tap/arena
</code></pre><p>or <a href="https://github.com/yonaskolb/Mint">Mint</a></p><pre data-language="bash"><code>mint install finestructure/arena
</code></pre><p>So you are really at most two command line invocations away from trying out an SPM package in a playground.</p><p>Arena has already helped me a lot evaluating and exploring packages and I hope it does for you, too.</p><p>Do you have questions or suggestions? Please get in touch via <a href="https://twitter.com/_sa_s">Twitter</a> or <a href="mailto:sas+blog@finestructure.co">email</a>!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://finestructure.co/posts/equal-widths</guid><title>SwiftUI: Equal widths view constraints</title><description></description><link>https://finestructure.co/posts/equal-widths</link><pubDate>Sun, 23 Feb 2020 11:47:24 +0100</pubDate><content:encoded><![CDATA[<h1>SwiftUI: Equal widths view constraints</h1><p>I love SwiftUI. It‚Äôs such a great technology and so much fun to use. And it recently sent me on a days long tangent to figure out a problem that used to be quite simple.</p><p>All I wanted to do was lay out something like this window on macOS:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-001-1.png" width=412 /><p>The only ‚Äútricky‚Äù thing with this is the requirement that both buttons be equal width and size-to-fit for the button with the longest title text.</p><p>Using Auto Layout, you simply create the buttons and add an ‚ÄúEqual Width‚Äù constraint and the layout mechanics take care of the details.</p><p>Now if you know of a simple way to do this in SwiftUI, please stop reading and email me. To the best of my knowledge this is not straightforward. You need to use what I‚Äôd consider the advanced feature of preferences to communicate the maximum width between the buttons.</p><p>I eventually arrived at the following solution, which I actually find quite nice and generic but took a while to assemble:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> foo = <span class="hljs-string">"Foo"</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> bar = <span class="hljs-string">"Bar"</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RightColumnWidth</span>: <span class="hljs-title">Preference</span> </span>{}
    <span class="hljs-keyword">let</span> rightColumnWidth = <span class="hljs-type">GeometryPreferenceReader</span>(
        key: <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">RightColumnWidth</span>&gt;.<span class="hljs-keyword">self</span>,
        value: { [$<span class="hljs-number">0</span>.size.width] }
    )
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> width: <span class="hljs-type">CGFloat?</span> = <span class="hljs-literal">nil</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Short"</span>, text: $foo)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Short"</span>)
                        .read(rightColumnWidth)
                        .frame(width: width)
                }
            }
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Bar"</span>, text: $bar)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Looooong"</span>)
                        .read(rightColumnWidth)
                        .frame(width: width)
                }
            }
        }
        .assignMaxPreference(<span class="hljs-keyword">for</span>: rightColumnWidth.key, to: $width)
    }
}
</code></pre><p>There are a few details hidden off-screen here but they are reusable machinery that you write once and can move into its own file somewhere.</p><p>The following describes the journey and the full details.</p><h2>First steps</h2><p>At the start of every problem is a web search and it quickly became obvious that a) I‚Äôm not alone in trying to figure this out, b) it‚Äôs definitely not a simple three liner, and c) I‚Äôll be regretting my OCD for not just getting the width of the widest button and hardcoding it for all of them.</p><p>The first lead I stumbled across was, of course, a <a href="https://stackoverflow.com/questions/56623310/swiftui-login-page-layout">Stackoverflow question</a> by Mostafa Mohamed Raafat. He was asking for help with the following layout (on iOS, but thanks to SwiftUI most of this is practically the same on macOS):</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-001-2.png" width=412 /><p>This looked like a good start and though I wasn‚Äôt too thrilled that <a href="https://stackoverflow.com/questions/56623310/swiftui-login-page-layout/56673501#56673501">the top answer</a> by Rob Mayoff was dealing with preferences it nonetheless looked like that part can be nicely abstracted away.</p><p>Not that there is anything wrong with preferences ‚Äì it just seems an odd bit of boilerplate required for something to seemingly mundane as equal widths. (I understand that it sort of has to be that way, because there is no constraint solver in SwiftUI but still ‚Äì it was a surprising amount of effort.)</p><p>So I plugged it into my project, adapted it for buttons and got this preview ‚Äì sweet.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-001-3.png" width=373 /><p>And then I ran it.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-001-4.png" width=412 /><p>ü§î</p><p>Bizarrely, it seems like at runtime the button <code>Text</code>s get pinned to width zero immediately, before their intrinsic sizes can be read and propagated by the preference system.</p><p>It might have something to do with how the <code>Text</code> is wrapped in a <code>Button</code>. I tried various ways of applying the <code>frame</code> inside and outside the <code>Button</code> and I did not find a way to get it to work at runtime with the method outlined in the Stackoverflow post.</p><p>This is actually the first time I‚Äôve seen a discrepancy between preview and device rendering.</p><h2>Attempt 2</h2><p>In my search for solutions I also came across a <a href="https://medium.com/better-programming/using-the-preferencekey-protocol-to-align-views-7f3ae32f60fc">post by Keith Lander</a> who‚Äôs using <code>PreferenceKey</code> to apply equal widths to labels. His approach is very similar to Rob Mayoff‚Äôs but of course when you‚Äôre stuck you better try everything and anything.</p><p>And in fact it turns out Keith‚Äôs approach fixes the issue for the buttons (while also working for labels).</p><p>Now instead of simply taking Keith‚Äôs solution and applying it, I merged it with my previous attempt to generalise size constraint propagation in SwiftUI and in the following I‚Äôll lay out (hah) that solution.</p><h2>The general principle</h2><p>Before we dive in, for those who haven‚Äôt read the underlying posts at all or in detail, the way the <code>PreferenceKey</code> mechanism works is the following:</p><p>You define a type conforming to the <code>PreferenceKey</code> protocol which holds data of type <code>V</code> you want to gather and a reducer, which aggregates into that data structure.</p><p>You trigger aggregation by applying a view modifier <code>preference(key: K.self, value: V)</code> where <code>K</code> is your <code>PreferenceKey</code> type and <code>V</code> is the data type you defined. You‚Äôll aggregate from all the places you call this view modifier. That‚Äôs why you define a reducer on <code>K</code>. (If this sounds a little abstract at the moment, don‚Äôt worry - it should become clearer further down.)</p><p>Finally, you call the <code>onPreferenceChange(key: K.self, perform: (V) -&gt; Void)</code> view modifier to do something whenever your preferences change. This is where we extract the reduced value associated with your <code>PreferenceKey</code>.</p><h2>The <code>PreferenceKey</code> struct</h2><p>So onwards to the actual implementation. What we need to do first is define our <code>PreferenceKey</code> type to hold the width(s):</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppendValue</span>&lt;<span class="hljs-title">T</span>: <span class="hljs-title">Preference</span>&gt;: <span class="hljs-title">PreferenceKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: [<span class="hljs-type">CGFloat</span>] { [] }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(value: <span class="hljs-keyword">inout</span> Value, nextValue: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Value</span>) {
        value.append(contentsOf: nextValue())
    }
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Value</span> = [<span class="hljs-type">CGFloat</span>]
}
</code></pre><p>As you can see, we choose <code>[CGFloat]</code> as our value and we reduce by appending.</p><p>This is actually one of the important differences between the first and the second approach: In case of <code>Text</code> labels, it suffices to define the reducer simply in terms of a maximum and the data type as a straight <code>CGFloat</code>.</p><p>The approach of using an array works in both cases and therefore is more generally applicable. Since it abstracts away (as you‚Äôll see), it‚Äôs probably best to simply use this solution in either case.</p><h2>What is <code>T: Preference</code>?</h2><p>Now you‚Äôre probably looking at that struct declaration and are wondering why on earth it is generic over <code>T: Preference</code>.</p><p>This is actually something you can completely ignore (and remove) if all you are collecting is a single preference. Just drop the <code>&lt;T: Preference&gt;</code> part and move on.</p><p>However, if for instance you have two different columns with different maximum widths you need to measure, you will need to define two distinct types for their <code>PreferenceKey</code>s.</p><p>And so instead of simple copying (and repeating) the complete <code>AppendValue</code> declaration with a different name we declare an empty protocol and a phantom type to achieve the same thing:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Preference</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">WidthLeftColumn</span>: <span class="hljs-title">Preference</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">WidhtRightColumn</span>: <span class="hljs-title">Preference</span> </span>{}
<span class="hljs-keyword">let</span> key1 = <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">WidthLeftColumn</span>&gt;.<span class="hljs-keyword">self</span>
<span class="hljs-keyword">let</span> key2 = <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">WidthRightColumn</span>&gt;.<span class="hljs-keyword">self</span>
</code></pre><p>If you‚Äôd like to learn more about phantom types, <a href="https://www.swiftbysundell.com/articles/phantom-types-in-swift/">John Sundell has you covered</a>. In the context of this post just treat it like a convenient labelling mechanism that avoids some code duplication.</p><h2>Calling <code>preference(key:, value:)</code></h2><p>With this in place we can now look at calling the ‚Äúreducer‚Äù. What we need to do is determine the width of the view we‚Äôre interested in and send it to the reducer.</p><p>The best way to get the width of a view is to use a <code>GeometryReader</code> on its background. For the measurement, we use a <code>Color.clear</code> view as follows:</p><pre data-language="swift"><code><span class="hljs-type">Button</span>(action: {}) {
    <span class="hljs-type">Text</span>(<span class="hljs-string">"Short"</span>)
        .background(<span class="hljs-type">GeometryReader</span> {
            <span class="hljs-type">Color</span>.clear.preference(key: key2.<span class="hljs-keyword">self</span>,
                                   value: [$<span class="hljs-number">0</span>.size.width])
        })
    ...
</code></pre><h2>Assigning the preference value</h2><p>The last step is to react to preference changes and to update a tracking <code>@State</code> variable with changes that we‚Äôve collected.</p><p>We define that variable as</p><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> width: <span class="hljs-type">CGFloat?</span> = <span class="hljs-literal">nil</span>
</code></pre><p>and assign the preference value via</p><pre data-language="swift"><code>.onPreferenceChange(key2) { prefs <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">let</span> maxPref = prefs.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>)
    <span class="hljs-keyword">if</span> maxPref &gt; <span class="hljs-number">0</span> {
        <span class="hljs-comment">// only set value if &gt; 0 to avoid pinning sizes to zero</span>
        <span class="hljs-keyword">self</span>.width = maxPref
    }
}
</code></pre><p>Finally, we want to set the button label frame to this width via the <code>.frame()</code> modifier:</p><pre data-language="swift"><code>.frame(width: width)
</code></pre><p>The complete <code>ContentView</code> looks as follows now:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> foo = <span class="hljs-string">"Foo"</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> bar = <span class="hljs-string">"Bar"</span>

    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> width: <span class="hljs-type">CGFloat?</span> = <span class="hljs-literal">nil</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Foo"</span>, text: $foo)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Short"</span>)
                        .background(<span class="hljs-type">GeometryReader</span> {
                            <span class="hljs-type">Color</span>.clear.preference(
                                key: key2.<span class="hljs-keyword">self</span>,
                                value: [$<span class="hljs-number">0</span>.size.width]
                            )
                        })
                        .frame(width: width)
                }
            }
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Bar"</span>, text: $bar)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Looooong"</span>)
                        .background(<span class="hljs-type">GeometryReader</span> {
                            <span class="hljs-type">Color</span>.clear.preference(
                                key: key2.<span class="hljs-keyword">self</span>,
                                value: [$<span class="hljs-number">0</span>.size.width]
                            )
                        })
                        .frame(width: width)
                }
            }
        }
        .frame(maxWidth: <span class="hljs-number">300</span>, maxHeight: <span class="hljs-number">150</span>)
        .onPreferenceChange(key2) { prefs <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> maxPref = prefs.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>)
            <span class="hljs-keyword">if</span> maxPref &gt; <span class="hljs-number">0</span> {
                <span class="hljs-comment">// only set value if &gt; 0 to avoid pinning sizes to zero</span>
                <span class="hljs-keyword">self</span>.width = maxPref
            }
        }
    }
}

<span class="hljs-comment">// extra declarations</span>

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Preference</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RightColumnWidth</span>: <span class="hljs-title">Preference</span> </span>{}
<span class="hljs-keyword">let</span> key2 = <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">RightColumnWidth</span>&gt;.<span class="hljs-keyword">self</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppendValue</span>&lt;<span class="hljs-title">T</span>: <span class="hljs-title">Preference</span>&gt;: <span class="hljs-title">PreferenceKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: [<span class="hljs-type">CGFloat</span>] { [] }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(value: <span class="hljs-keyword">inout</span> Value, nextValue: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Value</span>) {
        value.append(contentsOf: nextValue())
    }
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Value</span> = [<span class="hljs-type">CGFloat</span>]
}
</code></pre><p>That‚Äôs not so bad but there‚Äôs quite a bit of ceremony around reading and assigning the preferences that we could streamline.</p><h2>Refactoring</h2><p>There are three things we‚Äôll want to improve:</p><ol><li>Turn <code>.background(...)</code> into a view modifier so that we can hide and de-duplicate the <code>GeometryReader</code> mechanics</li><li>Generalise the mechanism so that we can re-use it for any dimension, not just <code>width</code></li><li>Wrap the <code>onPreferenceChange</code> modifier to hide the gory details</li></ol><h2>A generic geometry reader</h2><p>The first and second point are actually intertwined. If we want to wrap <code>.background(...)</code> in its own modifier, we need to pass it two parameters: 1. the preference key (<code>key2.self</code>) 2. the value getter (<code>[$0.size.width]</code>) The easiest way to do this is to define a wrapper type <code>GeometryPreferenceReader</code> that holds these values:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryPreferenceReader</span>&lt;<span class="hljs-title">K</span>: <span class="hljs-title">PreferenceKey</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-title">where</span> <span class="hljs-title">K</span>.<span class="hljs-title">Value</span> == <span class="hljs-title">V</span> </span>{
    <span class="hljs-keyword">let</span> key: <span class="hljs-type">K</span>.<span class="hljs-type">Type</span>
    <span class="hljs-keyword">let</span> value: (<span class="hljs-type">GeometryProxy</span>) -&gt; <span class="hljs-type">V</span>
}
</code></pre><p>This is a simple struct that holds the preference key type and a closure to extract a value <code>V</code> from a <code>GeometryProxy</code> input parameter.</p><p>The only tricky bit here is defining the generic types: We need to make sure that the preference key <code>K</code> we‚Äôre passing in wraps the same <code>Value</code> type as we‚Äôre getting out of the closure. (This is probably fairly obvious but I find it‚Äôs easy to lose track of what goes where when dealing with generics.)</p><p>With that we can now write <code>key2</code> as follows:</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> key2 = <span class="hljs-type">GeometryPreferenceReader</span>(
    key: <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">RightColumnWidth</span>&gt;.<span class="hljs-keyword">self</span>,
    value: { [$<span class="hljs-number">0</span>.size.width] }
)
</code></pre><p>This is nice ‚Äì we‚Äôve combined the phantom type which is the key for the preference with the accessor to the geometry. We‚Äôve tied these two together in a single place and simply deal with <code>key2</code> by itself from now on. This ensures we don‚Äôt accidentally mix up what value we pull into the preference in the various places where we read it.</p><h2><code>ViewModifier</code> conformance</h2><p>We‚Äôve got a little further to go before we can fully use <code>key2</code> to read the preferences.</p><p>What we‚Äôd like to be able to do is the following:</p><pre data-language="swift"><code><span class="hljs-type">Text</span>(<span class="hljs-string">"Short"</span>)
    .modifier(key2)
</code></pre><p>This doesn‚Äôt read very well at the moment, but we‚Äôll get to that.</p><p>To be able to use <code>key2</code> as a view modifier requires <code>GeometryPreferenceReader</code> to conform to the <code>ViewModifier</code> protocol. This is straightforward since it has access to the parameters we need:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">GeometryPreferenceReader</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        content
            .background(<span class="hljs-type">GeometryReader</span> {
                <span class="hljs-type">Color</span>.clear.preference(key: <span class="hljs-keyword">self</span>.key,
                                       value: <span class="hljs-keyword">self</span>.value($<span class="hljs-number">0</span>))
            })
    }
}
</code></pre><p>We simply use our key type <code>self.key</code> and the closure <code>self.value</code> as parameters to the <code>.preference</code> call, passing in the <code>GeometryReader</code> as <code>$0</code> to the <code>value</code> closure.</p><h2>Assigning the preference to <code>$width</code></h2><p>We also need to update our <code>onPreferenceChange</code> assignment to use the new key definition, <code>key2.key</code> instead of <code>key2</code>:</p><pre data-language="swift"><code>.onPreferenceChange(key2.key) { prefs <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">let</span> maxPref = prefs.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>)
    <span class="hljs-keyword">if</span> maxPref &gt; <span class="hljs-number">0</span> {
        <span class="hljs-comment">// only set value if &gt; 0 to avoid pinning sizes to zero</span>
        <span class="hljs-keyword">self</span>.width = maxPref
    }
}
</code></pre><p>There‚Äôs another argument here to deal with readability, so let‚Äôs tackle the final small change and factor the preference update handler into its own view extension.</p><p>We‚Äôd like to write the above as follows:</p><pre data-language="swift"><code>.assignMaxPreference(<span class="hljs-keyword">for</span>: rightColumnWidth.key, to: $width)
</code></pre><p>and for that we need to extend <code>View</code> with a function <code>assignMaxPreference</code>:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assignMaxPreference</span>&lt;K: PreferenceKey&gt;<span class="hljs-params">(
        <span class="hljs-keyword">for</span> key: K.<span class="hljs-keyword">Type</span>,
        to binding: Binding&lt;CGFloat?&gt;)</span></span> -&gt; some <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">K</span>.<span class="hljs-type">Value</span> == [<span class="hljs-type">CGFloat</span>] {

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.onPreferenceChange(key.<span class="hljs-keyword">self</span>) { prefs <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> maxPref = prefs.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>)
            <span class="hljs-keyword">if</span> maxPref &gt; <span class="hljs-number">0</span> {
                <span class="hljs-comment">// only set value if &gt; 0 to avoid pinning sizes to zero</span>
                binding.wrappedValue = maxPref
            }
        }
    }
}
</code></pre><p>There is probably a way to make this method slightly more generic than around <code>CGFloat</code> but there‚Äôs no real value in doing so, since we‚Äôll typically be dealing with values coming out of <code>GeometryReader</code>s. Also, <code>reduce(0)</code> limits how generic this can be and even if you avoid using <code>reduce</code> here you‚Äôll end up needing the notion of a zero to initialise the wrapped value.</p><p>It‚Äôs simply easier to stick with <code>CGFloat</code> and step around the issue.</p><h2>Final clean up</h2><p>Now that we have all the bits in place we can make a couple of final tweaks to tidy things up. Let‚Äôs rename <code>key2</code> to <code>rightColumnWidth¬†</code>:</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> rightColumnWidth = <span class="hljs-type">GeometryPreferenceReader</span>(key: <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">RightColumnWidth</span>&gt;.<span class="hljs-keyword">self</span>) { [$<span class="hljs-number">0</span>.size.width] }
</code></pre><p>and add a little extension to <code>View</code> so we can write:</p><pre data-language="swift"><code>.read(rightColumnWidth)
</code></pre><p>instead of <code>.modifier(rightColumnWidth)</code>:</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span>&lt;K: PreferenceKey, V&gt;<span class="hljs-params">(<span class="hljs-number">_</span> preference: GeometryPreferenceReader&lt;K, V&gt;)</span></span> -&gt; some <span class="hljs-type">View</span> {
    modifier(preference)
}
</code></pre><p>With that, the final <code>ContentView</code> looks like this:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> foo = <span class="hljs-string">"Foo"</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> bar = <span class="hljs-string">"Bar"</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RightColumnWidth</span>: <span class="hljs-title">Preference</span> </span>{}
    <span class="hljs-keyword">let</span> rightColumnWidth = <span class="hljs-type">GeometryPreferenceReader</span>(
        key: <span class="hljs-type">AppendValue</span>&lt;<span class="hljs-type">RightColumnWidth</span>&gt;.<span class="hljs-keyword">self</span>,
        value: { [$<span class="hljs-number">0</span>.size.width] }
    )
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> width: <span class="hljs-type">CGFloat?</span> = <span class="hljs-literal">nil</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Foo"</span>, text: $foo)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Short"</span>)
                        .read(rightColumnWidth)
                        .frame(width: width)
                }
            }
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"Bar"</span>, text: $bar)
                <span class="hljs-type">Button</span>(action: {}) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Looooong"</span>)
                        .read(rightColumnWidth)
                        .frame(width: width)
                }
            }
        }
        .frame(maxWidth: <span class="hljs-number">300</span>, maxHeight: <span class="hljs-number">150</span>)
        .assignMaxPreference(<span class="hljs-keyword">for</span>: rightColumnWidth.key, to: $width)
    }
}
</code></pre><p>With the following re-usable definitions:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryPreferenceReader</span>&lt;<span class="hljs-title">K</span>: <span class="hljs-title">PreferenceKey</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-title">where</span> <span class="hljs-title">K</span>.<span class="hljs-title">Value</span> == <span class="hljs-title">V</span> </span>{
    <span class="hljs-keyword">let</span> key: <span class="hljs-type">K</span>.<span class="hljs-type">Type</span>
    <span class="hljs-keyword">let</span> value: (<span class="hljs-type">GeometryProxy</span>) -&gt; <span class="hljs-type">V</span>
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">GeometryPreferenceReader</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        content
            .background(<span class="hljs-type">GeometryReader</span> {
                <span class="hljs-type">Color</span>.clear.preference(key: <span class="hljs-keyword">self</span>.key,
                                       value: <span class="hljs-keyword">self</span>.value($<span class="hljs-number">0</span>))
            })
    }
}

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Preference</span> </span>{}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppendValue</span>&lt;<span class="hljs-title">T</span>: <span class="hljs-title">Preference</span>&gt;: <span class="hljs-title">PreferenceKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: [<span class="hljs-type">CGFloat</span>] { [] }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(value: <span class="hljs-keyword">inout</span> Value, nextValue: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Value</span>) {
        value.append(contentsOf: nextValue())
    }
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Value</span> = [<span class="hljs-type">CGFloat</span>]
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assignMaxPreference</span>&lt;K: PreferenceKey&gt;<span class="hljs-params">(
        <span class="hljs-keyword">for</span> key: K.<span class="hljs-keyword">Type</span>,
        to binding: Binding&lt;CGFloat?&gt;)</span></span> -&gt; some <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">K</span>.<span class="hljs-type">Value</span> == [<span class="hljs-type">CGFloat</span>] {

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.onPreferenceChange(key.<span class="hljs-keyword">self</span>) { prefs <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> maxPref = prefs.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>)
            <span class="hljs-keyword">if</span> maxPref &gt; <span class="hljs-number">0</span> {
                <span class="hljs-comment">// only set value if &gt; 0 to avoid pinning sizes to zero</span>
                binding.wrappedValue = maxPref
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span>&lt;K: PreferenceKey, V&gt;<span class="hljs-params">(<span class="hljs-number">_</span> preference: GeometryPreferenceReader&lt;K, V&gt;)</span></span> -&gt; some <span class="hljs-type">View</span> {
        modifier(preference)
    }
}
</code></pre><p>And there we have it: a reusable way to propagate size constraints in SwiftUI.</p><p>Notably:</p><ul><li>We specify which dimension we are using in a single closure of shape <code>(GeometryReader) -&gt; V</code>. This can be a width, a height - anything or even any combination of things that <code>GeometryReader</code> can provide.</li><li>We can track multiple measurements simply by introducing different <code>GeometryPreferenceReaders</code> tagged by a phantom type.</li><li>Recording the preference is done via a call to the <code>.read(preference)</code> view modifier on each view that participates in the constraint, which is readable and concise.</li><li>The preference is applied in a single location by assigning it to a binding via <code>.assignMaxPreference(for: key, to: $width)</code>. That‚Äôs also readable and to the point.</li></ul><p>Note that this last step is one area where we may want to extend the system further, say for example if we want to track a minimum width.</p><p>In that case we could extend <code>View</code> with, say, <code>func assignMinPreference(for:To:)</code> and pick out the minimum value to assign to the binding.</p><p>I hope this may prove useful to others. If you have questions or know of a better way to achieve the same result, please let me know via <a href="https://twitter.com/_sa_s">Twitter</a> or <a href="mailto:sas+blog@finestructure.co">email</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://finestructure.co/posts/gala</guid><title>Enhance your SwiftUI previews with üé≠ Gala</title><description></description><link>https://finestructure.co/posts/gala</link><pubDate>Sun, 23 Feb 2020 11:47:08 +0100</pubDate><content:encoded><![CDATA[<h1>Enhance your SwiftUI previews with üé≠ Gala</h1><p>I switched to dark mode on my Mac recently and when doing so it occurred to me that I should really add previews for both colour schemes to my SwiftUI previews.</p><p>So off I went and wrote the following:</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Group</span> {
            <span class="hljs-type">ContentView</span>()
                .environment(\.colorScheme, .light)

            <span class="hljs-type">ContentView</span>()
                .environment(\.colorScheme, .dark)
        }
    }
</code></pre><p>That worked well enough but my left eye started twitching almost immediately at the thought that I‚Äôm going to have to duplicate this for every preview.</p><p>On top of that, most of my views take setup parameters or other configuration to make them look useful, like for instance this first one I was going to instrument:</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">SearchResultList</span>(query: <span class="hljs-string">""</span>,
                         results: .constant([<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"bar"</span>]),
                         selected: .constant(<span class="hljs-literal">nil</span>),
                         show: <span class="hljs-literal">true</span>)
            .padding()
            .frame(width: <span class="hljs-number">400</span>, height: <span class="hljs-number">300</span>)
    }
</code></pre><p>If during refactoring I change any of the properties in <code>SearchResultList</code> I‚Äôm going to have to change it for both the dark and the light variant. Plus, I‚Äôm going to want to add further variants with other configurations, to see how it lays out in different situations ‚Äì that‚Äôs all going to have to happen twice.</p><p>Clearly, that loop cannot remain unrolled! Because that‚Äôs what it really is, an unrolled loop.</p><p>After a bit of poking around I discovered* that you can actually use <code>ForEach</code> to loop over <code>ColorScheme</code> attributes:</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ForEach</span>([<span class="hljs-type">ColorScheme</span>.light, .dark], id: \.<span class="hljs-keyword">self</span>) { scheme <span class="hljs-keyword">in</span>
            <span class="hljs-type">SearchResultList</span>(query: <span class="hljs-string">""</span>,
                             results: .constant([<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"bar"</span>]),
                             selected: .constant(<span class="hljs-literal">nil</span>), show: <span class="hljs-literal">true</span>)
                .padding()
                .frame(width: <span class="hljs-number">400</span>, height: <span class="hljs-number">300</span>)
                .environment(\.colorScheme, scheme)
        }
    }
</code></pre><p><a href="https://twitter.com/_sa_s/status/1219892293030813696">My tweet</a> about this discovery was surprisingly popular and led me to explore this further, because while the <code>ForEach</code> loop is certainly a big improvement it still irked me that I‚Äôd have to spell out the list of colour schemes each time. (Yes, I‚Äôll happily spend a day saving the work of an hour üò≥.)</p><p>Anyway, this should be wrappable somehow ‚Äì and indeed it is. Thanks to Function Builder‚Äôs <code>ViewBuilder</code>, we can create the following wrapper:</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NightAndDay</span>&lt;A: View&gt;<span class="hljs-params">(<span class="hljs-number">_</span> name: String? = <span class="hljs-literal">nil</span>,
                                 @ViewBuilder items: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">A</span>) -&gt; some <span class="hljs-type">View</span> {
    <span class="hljs-type">ForEach</span>([<span class="hljs-type">ColorScheme</span>.light, .dark], id: \.<span class="hljs-keyword">self</span>) { scheme <span class="hljs-keyword">in</span>
        items()
            .previewDisplayName(name.<span class="hljs-built_in">map</span> { <span class="hljs-string">"\($0) \(scheme)"</span> } ?? <span class="hljs-string">"\(scheme)"</span>)
            .environment(\.colorScheme, scheme)
    }
}
</code></pre><p>and then use it as follows:</p><pre data-language="swift"><code>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
       <span class="hljs-type">NightAndDay</span> {
           <span class="hljs-type">ContentView</span>()
       }
   }
</code></pre><p>It‚Äôs like night and ‚Ä¶ üò∂</p><p>Of course, once I‚Äôm down a rabbit hole I‚Äôm going to make myself really comfortable and explore the corners.</p><p>Wouldn‚Äôt it be nice to have little wrappers for other attributes as well? And wouldn‚Äôt it be nice to have that in a package rather than copy functions around?</p><p>So from the rabbit hole I emerge with Gala, a little swift package manager library that brings you <code>NightAndDay</code> and some other helpers, like for instance <code>Layouts</code>:</p><pre data-language="undefined"><code>
    static var previews: some View {
        Layouts([.fixed(width: 200, height: 150),
                 .sizeThatFits,
                 .device], "Home") {
                ContentView()
        }
    }
</code></pre><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-002-1.png" width=380 /><p>Of course, if you really like scrolling your preview screen you‚Äôll nest these</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NightAndDay</span> {
            <span class="hljs-type">Layouts</span>([.fixed(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">150</span>),
                     .sizeThatFits,
                     .device], <span class="hljs-string">"Home"</span>) {
                    <span class="hljs-type">ContentView</span>()
            }
        }
    }
</code></pre><p>Gala also brings a <code>Device</code> iterator that allows you to render to different device screens without having to guess the stringly initialiser argument of <code>PreviewDevice</code>:</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Devices</span>([ .iPhoneX, .iPhone11, .iPhone11Pro ]) {
                <span class="hljs-type">ContentView</span>()
        }
    }
</code></pre><p>Thanks to autocompletion you don't have to remember the precise names. Please note that I‚Äôve taken particular care to transform Apple's fantastic product names into identifiers. For instance:</p><ul><li><code>iPadPro9¬∑7inch</code></li><li><code>iPhoneX Ä</code></li><li><code>appleWatchSeries5Ôπò40mm</code></li></ul><p>Thanks to Swift's support of unicode in identifiers you can use these free of ugly underscores (and thanks to autocomplete you can actually type them üòÖ).</p><p>You can also use <code>Devices.iPhones</code> (<code>iPads</code>, <code>watches</code>, <code>tvs</code>) to preview all of them:</p><pre data-language="swift"><code>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Devices</span>(.iPhones) {
            <span class="hljs-type">ContentView</span>()
        }
    }
</code></pre><p>You can find <a href="https://github.com/finestructure/Gala">Gala on Github</a>. Simply import it as a Swift Package into your Xcode project and off you go.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/post-2020-002-2.png" width=780 /><p>I hope you find it useful. Please get in touch via <a href="https://twitter.com/_sa_s">Twitter</a> or <a href="mailto:sas+blog@finestructure.co">email</a>if you have questions or via Github if you have fixes or can think of improvements.</p><p>* I‚Äôve since found while researching other attributes to loop over for this blog post that the <code>ForEach</code> loop trick has been mentioned in <a href="https://developer.apple.com/wwdc19/233">WWDC19 session 233 ‚ÄúMastering Xcode Previews‚Äù</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://finestructure.co/posts/prometheus-2020-1</guid><title>Monitoring with Prometheus, Grafana &amp; Docker (Updated)</title><description>A revised version of how to get started with Prometheus, Grafana &amp; Docker.</description><link>https://finestructure.co/posts/prometheus-2020-1</link><pubDate>Sun, 23 Feb 2020 00:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Monitoring with Prometheus, Grafana &amp; Docker (Updated)</h1><h2>Introduction</h2><p>The most popular post on my blog is about setting up and configuring Prometheus and Grafana. I wrote this post in 2016 shortly after researching and deploying a monitoring solution for a startup.</p><p>Four years on I have to say that decision to go for Prometheus and Grafana has aged very, very well. I am still running that same setup, now across many more machines, and successfully.</p><p>Prometheus and Grafana, in combination with Docker, are such a great choice for small teams, because they allow you to get started with minimal fuss and then grow the system into something quite complex and very capable.</p><p>My decision to go with Prometheus and Grafana has aged well and so has mostly this blog post about it. Thanks to docker images and pinned versions almost everything still works ‚Äì which is actually quite remarkable given the fast pace at which many parts of our tech stacks evolve.</p><p>Even things that work can do with a little maintenance every once in a while though and so it is time to give this blog post another coat of paint. I‚Äôll be back in the mid 20s to see how everything is holding up!</p><h2>Original Introduction</h2><p>The choice of monitoring systems out there is overwhelming. When I first set up my current monitoring system for a handful of servers in 2016, it became clear that many of the go-to solutions like Nagios, Sensu, New Relic would be either too heavy or too expensive ‚Äì or both.</p><p>What I really needed at the time was something lean I could spin up in a docker container and then ‚Äògrow‚Äô by extending the configuration or adding components as and when my needs change.</p><p>With those requirements in hand I soon came across Prometheus, a monitoring system and time series database, with its de-facto graphical front-end Grafana. I set it up for a trial run and it fit my needs perfectly.</p><p>While the set-up went fairly smoothly I did find some of the information on the web for similar set-ups slightly outdated and wanted to pull everything together in one place as a reference. This covers the as-of-writing current versions of Prometheus (0.18.0) and Grafana (3.0.1).</p><p>Because pictures are worth more than a thousand words, here‚Äôs what a Prometheus powered Grafana dashboard looks like:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/1-grafana.png" width="800"/><h2>Requirements</h2><p>In order to follow along, you will need only two things - <a href="https://docs.docker.com/engine/installation/">docker</a> - <a href="https://docs.docker.com/compose/install/">docker-compose</a> Follow the links for installation instructions. The versions used are docker 1.11 and docker-compose 1.7. Note that older versions will very likely work as well, but I have not tested it.</p><h2>Components</h2><p>Prometheus is a system originally developed by SoundCloud as part of a move towards a micro-service architecture. As such, it consists of a few moving parts that are launched and configured separately.</p><p>While this may be a bit more complicated to set up and manage on the surface, thanks to docker-compose it is actually quite easy to bundle everything up as a single service again with only one service definition file and (in our example) three configuration files.</p><p>Before we dive in, here‚Äôs a brief run-down of the components and what they do:</p><ul><li><strong>Prometheus</strong> ‚Äì this is the central piece, it contains the time series database and the logic of scraping stats from exporters (see below) as well as alerts.</li><li><strong>Grafana</strong> is the ‚Äòface‚Äô of Prometheus. While Prometheus exposes some of its internals like settings and the stats it gathers via basic web front-ends, it delegates the heavy lifting of proper graphical displays and dashboards to Grafana.</li><li><strong>Alertmanager</strong> manages the routing of alerts which Prometheus raises to various different channels like email, pagers, slack - and so on. So while Prometheus collects stats and raises alerts it is completely agnostic of where these alerts should be displayed. This is where the alertmanager picks up.</li><li><strong>Exporters</strong> are http endpoints which expose ‚Äòprometheus metrics‚Äô for scraping by the Prometheus server. What this means is that this is a pull set-up. Note that it is also possible to set up a push-gateway which is essentially an intermediary push target which Prometheus can then scrape. This is useful for scenarios where pull is not appropriate or feasible (for example short lived processes).</li></ul><h2>Getting started</h2><h3>Launching Prometheus</h3><p>We‚Äôll start off by launching Prometheus via a very simple docker-compose.yml configuration file</p><pre data-language="yaml"><code><span class="hljs-comment"># docker-compose.yml</span>
<span class="hljs-attr">version:</span> <span class="hljs-string">'2'</span>
<span class="hljs-attr">services:</span>
<span class="hljs-attr">prometheus:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:0.18.0</span>
    <span class="hljs-attr">volumes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">./prometheus.yml:/etc/prometheus/prometheus.yml</span>
    <span class="hljs-attr">command:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'-config.file=/etc/prometheus/prometheus.yml'</span>
    <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'9090:9090'</span>
</code></pre><p>and a prometheus configuration file <code>prometheus.yml</code>:</p><pre data-language="yaml"><code><span class="hljs-comment"># prometheus.yml</span>
<span class="hljs-attr">global:</span>
    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">5s</span>
    <span class="hljs-attr">external_labels:</span>
        <span class="hljs-attr">monitor:</span> <span class="hljs-string">'my-monitor'</span>
<span class="hljs-attr">scrape_configs:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'prometheus'</span>
      <span class="hljs-attr">target_groups:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> <span class="hljs-string">['localhost:9090']</span>
</code></pre><p>As you can see, inside <code>docker-compose.yml</code> we map the prometheus config file into the container as a volume and add a <code>-config.file</code> parameter to the command pointing to this file.</p><p>To launch prometheus, run the command</p><pre data-language="bash"><code>docker-compose up
</code></pre><p>Visit <a href="http://localhost:9090/status">http://localhost:9090/status</a> to confirm the server is up and running and the configuration is the one we provided.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/2-prometheus.png" width="800"/><h3>Targets</h3><p>Further down below the ‚ÄòConfiguration‚Äô on the status page you will find a section ‚ÄòTargets‚Äô which lists a ‚Äòprometheus‚Äô endpoint. This corresponds to the <code>scrape_configs</code> setting by the same <code>job_name</code> and is a source of metrics provided by Prometheus. In other words, the Prometheus server comes with a metrics endpoint - or exporter, as we called it above - which reports stats for the Prometheus server itself.</p><p>The raw metrics can be inspected by visiting <a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a>.</p><h3>Adding a node-exporter target</h3><p>While it‚Äôs certainly a good idea to monitor the monitoring service itself, this is just going to be an additional aspect of the set-up. The main point is to monitor other things by adding targets to the <code>scrape_configs</code> section in <code>prometheus.yml</code> . As described above, these targets need to export metric in the prometheus format.</p><p>One such exporter is <a href="https://github.com/prometheus/node_exporter">node-exporter</a>, another piece of the puzzle provided as part of Prometheus. What it does is collect system metrics like cpu/memory/storage usage and then it exports it for Prometheus to scrape. The beauty of this is that it can be run as a docker container while also reporting stats for the host system. It is therefore very easy to instrument any system that can run docker containers.</p><p>We will add a configuration setting to our existing <code>docker-compose.yml</code> to bring up <code>node-exporter</code> alongside <code>prometheus</code>. However, this is mainly for convenience in this example as in a normal setup where one prometheus instance is monitoring many other machines these other exporters would likely be launched by other means.</p><p>Here‚Äôs what our new <code>docker-compose.yml</code> looks like:</p><pre data-language="yaml"><code><span class="hljs-comment"># docker-compose.yml</span>
<span class="hljs-attr">version:</span> <span class="hljs-string">'2'</span>
<span class="hljs-attr">services:</span>
    <span class="hljs-attr">prometheus:</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:0.18.0</span>
        <span class="hljs-attr">volumes:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">./prometheus.yml:/etc/prometheus/prometheus.yml</span>
        <span class="hljs-attr">command:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">'-config.file=/etc/prometheus/prometheus.yml'</span>
        <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">'9090:9090'</span>
    <span class="hljs-attr">node-exporter:</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">prom/node-exporter:0.12.0rc1</span>
        <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">'9100:9100'</span>
</code></pre><p>We simply added a <code>node-exporter</code> section. Configuring it as a target only requires a small extension to <code>prometheus.yml</code>:</p><pre data-language="yaml"><code><span class="hljs-comment"># prometheus.yml</span>
<span class="hljs-attr">global:</span>
    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">5s</span>
    <span class="hljs-attr">external_labels:</span>
        <span class="hljs-attr">monitor:</span> <span class="hljs-string">'my-monitor'</span>
<span class="hljs-attr">scrape_configs:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'prometheus'</span>
      <span class="hljs-attr">target_groups:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> <span class="hljs-string">['localhost:9090']</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'node-exporter'</span>
      <span class="hljs-attr">target_groups:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> <span class="hljs-string">['node-exporter:9100']</span>
</code></pre><p>Note that we reference <code>node-exporter</code> by its service name which we specified in <code>docker-compose.yml</code> (the service label). Docker Compose makes the service available by that name for inter-container connectivity.</p><h2>Grafana</h2><p>At this point we‚Äôve set up a Prometheus server in a basic configuration with two probes exporting metrics. If you‚Äôve had a look around the Prometheus web front-end you‚Äôve probably noticed that there‚Äôs a rudimentary interface in place to <a href="http://localhost:9090/graph#%5B%7B%22range_input%22%3A%221h%22%2C%22end_input%22%3A%22%22%2C%22step_input%22%3A%22%22%2C%22stacked%22%3A%22%22%2C%22expr%22%3A%22node_load1%22%2C%22tab%22%3A0%7D%2C%7B%22range_input%22%3A%221h%22%2C%22end_input%22%3A%22%22%2C%22step_input%22%3A%22%22%2C%22stacked%22%3A%22%22%2C%22expr%22%3A%22node_load1%22%2C%22tab%22%3A0%7D%5D">look at metrics</a>.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/3-grafana-graph.png" width="800"/><p>This helps to get an overview or take a quick look but Grafana offers a much more powerful picture, as the very first screenshot in this blog post shows.</p><p>Adding Grafana to our set-up is again a simple extension to <code>docker-compose.yml</code>. Append the following lines:</p><pre data-language="yaml"><code><span class="hljs-attr">grafana:</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana:3.0.0-beta7</span>
        <span class="hljs-attr">environment:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">GF_SECURITY_ADMIN_PASSWORD=pass</span>
        <span class="hljs-attr">depends_on:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus</span>
        <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">"3000:3000"</span>
</code></pre><p>The complete final version version of all config files can be found in this <a href="https://github.com/finestructure/blogpost-prometheus">github repository</a>.</p><p>After restarting the service with</p><pre data-language="bash"><code>docker-compose up
</code></pre><p>you can access Grafana at <a href="http://localhost:3000/login">http://localhost:3000/login</a>:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/4-grafana-login.png" width="800"/><h2>Persistence</h2><p>Up to this point we‚Äôve simply set things up via configuration files to bring up the service and while we did record some metrics within the running containers we‚Äôve not made any changes that we would necessarily want to keep around between restarts of the system.</p><p>Obviously this is fine for testing but before we go on to configure dashboards, we‚Äôll want to make sure everything is actually persisted in docker volumes.</p><p>To do so, we append the following lines to our <code>docker-compose.yml</code> configuration file:</p><pre data-language="yaml"><code><span class="hljs-attr">volumes:</span>
        <span class="hljs-attr">prometheus_data:</span> <span class="hljs-string">{}</span>
        <span class="hljs-attr">grafana_data:</span> <span class="hljs-string">{}</span>
</code></pre><p>This defines two data volumes, one for Prometheus and one for Grafana. To use them, add the following lines to their service definition (adding a new <code>volumes:</code> section to grafana‚Äòs service definition):</p><pre data-language="yaml"><code><span class="hljs-attr">services:</span>
        <span class="hljs-attr">prometheus:</span>
            <span class="hljs-string">...</span>
            <span class="hljs-attr">volumes:</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus_data:/prometheus</span>
                <span class="hljs-string">...</span>
        <span class="hljs-attr">grafana:</span>
            <span class="hljs-string">...</span>
            <span class="hljs-attr">volumes:</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">grafana_data:/var/lib/grafana</span>
</code></pre><p>This tells <code>docker-compose</code> to map the docker volumes we‚Äôve defined into the containers where their data directories are located. The docker volumes will be created if they don‚Äôt exist and will persist even after the containers are stopped and removed.</p><p>Now because we‚Äôve been running the service before we need to remove the containers before we bring it back up again. (Otherwise you will get a <code>WARNING: Service "prometheus" is using volume "/prometheus" from the previous container</code>, going on to inform you that the volume will not be used.)</p><p>So we run</p><pre data-language="yaml"><code><span class="hljs-string">docker-compose</span> <span class="hljs-string">rm</span>
</code></pre><p>followed by</p><pre data-language="yaml"><code><span class="hljs-string">docker-compose</span> <span class="hljs-string">up</span>
</code></pre><p>and everything should be the same as before, except now we save all changes (and recorded metrics) to the specified docker volumes.</p><h2>Configuring Grafana</h2><p>As you‚Äôve probably noticed, we‚Äôve specified the admin user‚Äôs password in docker-compose.yml as <code>pass</code>. Use these credentials to log in and navigate to <a href="http://localhost:3000/datasources">http://localhost:3000/datasources</a> to set up our Prometheus server as the data source for Grafana. Give it a name, make sure you select ‚ÄúPrometheus‚Äù as the type, and set the URI to <code>http://prometheus:9090</code>.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/5-grafana-config.png" width="800"/><p>Note again that we can use the service name as the host name for the URI to connect Grafana to Prometheus.</p><p>Next head over to <a href="http://localhost:3000/dashboard/new">http://localhost:3000/dashboard/new</a> to create a new dashboard and add a graph:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/6-grafana-add-graph.png" width="800"/><p>Make sure to select ‚ÄúMy Monitor‚Äù as the panel data source and after doing so you can use the metric lookup field to filter for any of the metrics available in Prometheus.</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/7-grafana-panel.png" width="800"/><p>Grafana offers <a href="http://docs.grafana.org/reference/graph/">a lot of options</a> to create great looking graphs and all of this is extensively documented at <a href="http://docs.grafana.org">http://docs.grafana.org</a>.</p><h2>Limitations</h2><p>The current set-up has a few limitations which make it unsuitable to be run as-is except for testing and learning purposes:</p><ul><li>The Prometheus web front-end is exposed on port 9090 and freely accessible without authentication.</li><li>Grafana supports authentication but is not configured for SSL.</li></ul><p>In addition, while we display metrics in graphs we have not yet set up any automatic alerts that trigger when certain conditions are met. And these alerts should be delivered as notifications in various way, for example via email or a slack message.</p><p>Please see <a href="https://finestructure.co/blog/2016/6/9/monitoring-with-prometheus-grafana-docker-part-2">part 2 of this mini-series</a> where these limitations are being addressed.</p><p>If you have any questions or comments, please get in touch!</p>]]></content:encoded></item></channel></rss>