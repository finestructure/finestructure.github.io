<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="og:site_name" content="finestructure"/>
		<link rel="canonical" href="https://finestructure.co/posts/state-of-the-app"/>
		<meta name="twitter:url" content="https://finestructure.co/posts/state-of-the-app"/>
		<meta name="og:url" content="https://finestructure.co/posts/state-of-the-app"/>
		<title>State of the App: State Surfing | finestructure</title>
		<meta name="twitter:title" content="State of the App: State Surfing | finestructure"/>
		<meta name="og:title" content="State of the App: State Surfing | finestructure"/>
		<meta name="description" content="Browse your app‚Äôs state history like a git repository"/>
		<meta name="twitter:description" content="Browse your app‚Äôs state history like a git repository"/>
		<meta name="og:description" content="Browse your app‚Äôs state history like a git repository"/>
		<meta name="twitter:card" content="summary"/>
		<link rel="stylesheet" href="/fs-styles.css" type="text/css"/>
		<link rel="stylesheet" href="/highlight.css" type="text/css"/>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mukta:300,800|Roboto+Mono&display=swap" type="text/css"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<link rel="shortcut icon" href="/images/favicon.png" type="image/png"/>
		<link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to finestructure"/>
		<meta name="twitter:image" content="https://finestructure.co/images/finestructure.png"/>
		<meta name="og:image" content="https://finestructure.co/images/finestructure.png"/>
	</head>
	<body class="item-page">
		<header>
			<div class="wrapper">
				<div class="navigation">
					<a class="site-name" href="/">
						<img src="/images/finestructure.png" width="400"/>
					</a>
					<nav>
						<ul>
							<li>
								<a class="selected" href="/posts">Blog</a>
							</li>
							<li>
								<a href="/about">About</a>
							</li>
						</ul>
					</nav>
				</div>
			</div>
		</header>
		<div class="wrapper">
			<article>
				<div class="content"><h1>State of the App: State Surfing</h1><p>Imagine you could scroll through your app states like your browsing history.</p><p>What if the actions you take via the user interface were visible like a Git graph and you could jump around between revisions?</p><p>Or how about exporting any state into a file and re-applying it at a later time?</p><p>These are things I‚Äôve always wanted to be able to do while developing an app and it is now possible, with <a href="https://github.com/finestructure/Historian">Historian</a> and Composable Architecture, an application architecture <a href="https://www.twitter.com/mbrandonw">Brandon Williams</a> and <a href="https://www.twitter.com/stephencelis">Stephen Celis</a> are developing in their video series over <a href="https://www.pointfree.co/collections/composable-architecture">at Pointfree.co</a>.</p><p>Have a look at it in action:</p><div class="wrapper"><iframe src="https://player.vimeo.com/video/402216905" width="640" height="332" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div><h2>Composable Architecture</h2><p>I‚Äôve largely ignored the app architecture ‚Äúscene‚Äù, because it mostly seems to be about MVC variants or geared towards apps of massive scale that I have little opportunity to be involved with. I get why they exists and they probably solve tricky problems at scale but for what I do, MVC with sensible composition was fine.</p><p>Despite this, though, I have recently transitioned an app prototype over to Composable Architecture, and I feel it is of enormous value for app development.</p><p>It‚Äôs not just that it enables history browsing. There are other significant advantages to adopting Composable Architecture, which make it a very compelling choice. I will get to that in a moment but first let‚Äôs look at what Composable Architecture actually is.</p><h2>State, Action, Reducer</h2><p>Since <a href="https://pointfree.co">Pointfree.co</a> is a subscription service and not everyone reading this post will be a subscriber (you should subscribe though, what are you doing) I will briefly recap what it entails. While Pointfree.co‚Äôs material will help you understand the architecture much better than I could ever do it justice, everything I talk about and show is available as open source, and ready to be included in your own projects.</p><p>At the core of ‚ÄúComposable Architecture‚Äù rests the following mechanism:</p><img src="https://f000.backblazeb2.com/file/finestructure-public-images/posts/CA-state-diagram.png" width="720"/><p>Your app‚Äôs entire state is represented by a <code>struct</code> we‚Äôll call <code>State</code> and which is kept in a <code>Store</code>. In order to change values in this <code>struct</code> you send <code>Action</code>s to the <code>Store</code>, defined in an <code>enum Action</code>. These actions are applied to the <code>struct</code> via a <code>Reducer</code> function, which is essentially a function of shape <code>(inout State, Action) -&gt; [Effect&lt;Action&gt;]</code>.</p><p>The <code>[Effect&lt;Action&gt;]</code> array deals with an aspect that often complicates app development: side effects. They encapsulate everything and anything you might want to do that does not directly apply to your <code>State</code>, for instance:</p><ul><li>file system reads/writes</li><li>network requests</li><li>notifications</li></ul><p>These actions will either be ‚Äúfire and forget‚Äù, i.e. <code>() -&gt; Void</code>, or send a new action to your <code>Store</code>, <code>() -&gt; Action</code></p><p>This may seem quite abstract but you can explore all the details in an <a href="https://github.com/finestructure/PFCompArch">example app called PFCompArch</a> using an implementation of the <a href="https://github.com/finestructure/CompArch">Composable Architecture library</a>. Note that Pointfree.co have pretty much confirmed that they will come out with an official release of their architecture, um, <a href="https://twitter.com/pointfreeco/status/1233577564225957888">someday</a> üòÖ. In the meantime, the above will get you started.</p><p>There are a few very interesting consequences that come with this architecture:</p><ul><li>Your entire app state is represented by a single <code>struct</code>. If this struct is <code>Codable</code> (and that‚Äôs something that is quite feasible and desirable), nothing stops you from recording, archiving, or transmitting this state and inspecting or re-applying it to your application at a later time.</li><li>The stream of your actions gives you a detailed timeline of changes to your app. It is like a git graph for your app state where each action constitutes a diff that is applied to an initial state. Just like you can create a patch file from a commit, you can take an action and apply it to a <code>Store</code>.</li><li>Since the reducer is a pure function and the only way to modify your app‚Äôs state, everything becomes very easily testable. And since you can easily prepare the initial state, it becomes much easier to test intricate scenarios.</li><li>Finally, Composable Architecture, is, well, composable. That means the <code>State</code>, <code>Action</code>s, and <code>Reducer</code> can be broken down into smaller components, just like SwiftUI views, and then recomposed into the entire whole. This makes individual parts of your app their only independent world that you can work on and refine in isolation. In fact, Pointfree.co go so far as to place app sections into their own modules that can be compiled and used ‚Äì in SwiftUI previews or Swift playgrounds ‚Äì entirely on their own.</li></ul><h2>The Reality</h2><p>Now I‚Äôm not going to lie: the reality of applying this fantastic architecture to an app is not entirely trivial. While Brandon and Stephen have done an amazing job of creating their own example app that aims to cover all the essential parts app development touches on, invariably you will come upon areas that are not covered by an example.</p><p>This is where it really helps to have built an intuition and understanding of how the concept works and what tools you have available. I will admit I feel like I'm still in the middle of this process. However, after several months of chipping away at this off and on, I‚Äôve finally managed to transition an app prototype over to the Composable Architecture, and am <em>very</em> happy with the results.</p><p>While my goal initially was to simply have better testing capabilities, something else struck me and it is something I recall Chris Eidhof <a href="https://twitter.com/chriseidhof/status/999994103839580162?s=21">also exploring</a>: creating a history viewer for your app state.</p><h2>Past, Present, and Future</h2><p>Amazingly, once I was done transitioning my app over to the Composable Architecture, it took me well inside a day to add this history viewing capability. Most of the time was actually spent working around some SwiftUI issues and conceptual gaps I still had with the Composable Architecture.</p><p>The result makes me really happy. In fact, inspecting the action stream gave immediate benefits by making obvious some necessary changes to the app‚Äôs actions, breaking them down further into more granular steps.</p><p>Take another look <a href="https://vimeo.com/402216905 "Demo video"">at the video</a> at the beginning of this blog post and note how you can not only observe the actions and move through the states. You can also drag a state snapshot out to the desktop where it is saved as a JSON representation. And later, you can drop it back onto the history viewer to re-apply it. This is persisting your entire app state via drag and drop.</p><p>Imagine how this can facilitate things like</p><ul><li>getting the app back into a state to debug an intricate UI or network issue</li><li>re-instate a nice app view for marketing screenshots</li><li>debug and improve your event stream by observing redundancies or weird action sequences ‚Äì because haven‚Äôt we all seen UI glitches where we wondered what triggered <em>that</em> under the hood</li></ul><h2>Multipeer streaming, a.k.a ‚ÄúState Surfing‚Äù</h2><p>Now, what <em>actually</em> prompted me to explore a history viewer was a thought that occurred to me when I saw Gui Rambos <a href="https://twitter.com/_inside/status/1233733464790372353">announcement of MultipeerKit</a> recently: what if I streamed actions and app state over the network and displayed them?</p><p>Because while I find the initial take to add a history as a window to a macOS app quite nice and useful, that‚Äôs not something that as easily done on iOS. Even if you bring up a debug view inside you app, you‚Äôll be hard pressed to operate it at the same time.</p><p>So how about having a history viewer that receives state messages over the network while your iOS app retains its regular interface and the viewer acts as the extra window?</p><h2>Introducing <a href="https://github.com/finestructure/Historian">Historian</a></h2><p>Thanks to SwiftUI and MultipeerKit‚Äôs support for macOS and iOS, it was surprisingly simple to bring the viewer to both platforms and allow inspection and ‚Äústate surfing‚Äù from whichever device you have available:</p><div class="wrapper"><iframe src="https://player.vimeo.com/video/397601668" width="640" height="570" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div><p>What you see here is the same macOS app as before, except this time its history is being observed and displayed on an iOS device.</p><p>Note that the viewer is entirely generic. It accepts a <code>String</code> description for the action and a <code>Data</code> object holding the app‚Äôs state. Clicking a row sends the <code>Data</code> back to the app, which decodes it and resets its state to what it received.</p><p>As mentioned, the transmitting app doesn‚Äôt have to be a macOS app. You can just as well observe an iOS app with the iOS history viewer. Or observe it with the macOS version ‚Äì either combination works. You can even observe an app from two viewers at the same time.</p><p>I have packaged up the history viewer ‚Äì <a href="https://github.com/finestructure/Historian">Historian</a> ‚Äì and published it on Github. Again, this viewer app is entirely stand-alone and listens on the local network for state broadcasts from an app that is appropriately instrumented to send them.</p><p>We‚Äôll cover those instrumentation steps next.</p><h2>Integrating Historian in your app</h2><p>Adding support for Historian essentially means to set up your app to send its actions as <code>String</code>s and its state as <code>Data</code> at a strategic top level location where all actions and state information is available. You do this by conforming to protocols.</p><p>The biggest hurdle to ‚ÄúState Surfing‚Äù is clearly adopting a whole new app architecture but there are enough great reasons to do this already ‚Äì browsing your app history is just the cherry on top.</p><p>You can head over to <a href="https://www.pointfree.co/collections/composable-architecture">Pointfree.co‚Äôs collection of videos</a> to get started with adopting their Composable Architecture in case you haven‚Äôt done so already.</p><p>The good news is that once you have transitioned your app to the Composable Architecture ‚Äì or if you‚Äôve been using it all along ‚Äì you are almost all the way there to surf your app states already.</p><h2>Step by step</h2><p>Let‚Äôs look at the steps required to add support for Historian to your Composable Architecture app.</p><p>Here‚Äôs an outline of the steps required. In order to establish common nomenclature, I assume that your top level view is a <code>ContentView</code> and that this view‚Äôs state is held in a struct <code>ContentView.State</code> ‚Äì i.e. a <code>struct State</code> declared within <code>ContentView</code>.</p><p>This is a practise I adopted for my Composable Architecture apps and which allows me to refer to the state simply as <code>State</code> when within view context and to use the view as a namespace whenever I refer to it externally. (See <a href="https://twitter.com/_sa_s/status/1239666390312923137">this tweet</a> on how to avoid name collisions with SwiftUI‚Äôs <code>@State</code>.)</p><p>There are only a few steps required to support Historian:</p><ol><li>Add the <code>HistoryTransceiver</code> SPM package as a dependency</li><li>Make your app‚Äôs <code>ContentView.State</code> adopt the <code>StateInitializable</code> protocol</li><li>Make your app‚Äôs <code>ContentView</code> adopt the <code>StateSurfable</code> protocol</li><li>In your <code>SceneDelegate</code> (or <code>AppDelegate</code> for macOS) where you instantiate your <code>ContentView</code> and pass it to the hosting controller, instead instantiate <code>HistoryTransceiverView&lt;ContentView&gt;</code>, and call <code>resume</code> to start broadcasting.</li></ol><p>Let‚Äôs go through the steps, what they entail, and why they‚Äôre required in detail.</p><h2>Adding <code>HistoryTransceiver</code></h2><p>The <code>HistoryTransceiver</code> SPM package brings with it everything that‚Äôs required to start streaming your states and to integrate with Historian. Most importantly, it declares two protocols, <code>StateInitializable</code> and <code>StateSurfable</code> which specify all the required implementation details you need to take care of. The main task is to adopt these two protocols.</p><h2>Adopting <code>StateInitializable</code></h2><p>The first one is simple: <code>StateInitializable</code> essentially specifies the requirements to transmit and instantiate <code>State</code> from <code>Data</code>:</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">StateInitializable</span>: <span class="hljs-title">Codable</span> </span>{
    <span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">init</span>?(from data: <span class="hljs-type">Data</span>)
}
</code></pre><p>Your <code>State</code> needs to be <code>Codable</code> and provide <code>init?(from: data: Data)</code> in order to be streamed and instantiated from received <code>Data</code>.</p><p>The other required initialiser, <code>init()</code>, represents the initial or ‚Äúempty‚Äù state. When users wind back the history all the way to the start, <code>Historian</code> will send a <code>nil</code> data <code>Message</code> as a signal, which in turn will inject a <code>State</code> instantiated from <code>init()</code> into your app. Therefore, you need to implement <code>init()</code> such that it provides your app‚Äôs initial state.</p><h2>Adopting <code>StateSurfable</code></h2><p>The <code>StateSurfable</code> protocol deals with preparing your top level view to be wrapped in a <code>HistoryTranceiverView</code>. This view handles broadcasting state changes and receiving and applying state updates from Historian.</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">StateSurfable</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span>: <span class="hljs-type">StateInitializable</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Action</span>
    <span class="hljs-keyword">var</span> store: <span class="hljs-type">Store</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reducer: <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(store: Store&lt;State, Action&gt;)</span></span> -&gt; <span class="hljs-type">Self</span>
}
</code></pre><p>By implementing the required methods, you are preparing <code>ContentView</code> to be swapped out for <code>HistoryTranceiverView</code></p><p>A typical implementation of this protocol should be as simple as the following:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">StateSurfable</span> </span>{
     <span class="hljs-keyword">typealias</span> <span class="hljs-type">State</span> = <span class="hljs-type">ContentView</span>.<span class="hljs-type">State</span>      <span class="hljs-comment">// redundant, for illustration purposes</span>
     <span class="hljs-keyword">typealias</span> <span class="hljs-type">Action</span> = <span class="hljs-type">ContentView</span>.<span class="hljs-type">Action</span>    <span class="hljs-comment">// redundant, for illustration purposes</span>

     <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(store: Store&lt;State, Action&gt;)</span></span> -&gt; <span class="hljs-type">ContentView</span> {
         <span class="hljs-type">ContentView</span>(store: store)
     }
     <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reducer: <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Action</span>&gt; {
         <span class="hljs-type">ContentView</span>.reducer                  <span class="hljs-comment">// redundant, for illustration purposes</span>
     }
 }
</code></pre><p>It is essentially a mapping of your types and the reducer function to what <code>HistoryTransceiverView</code> expects and uses to wire everything up.</p><h2>Update your <code>SceneDelegate</code> or <code>AppDelegate</code></h2><p>We‚Äôre almost done now. The final step is to swap out your <code>ContentView</code>. In a typical application this looks as follows. Find and replace</p><pre data-language="swift"><code>window.rootViewController = <span class="hljs-type">UIHostingController</span>(rootView: <span class="hljs-type">ContentView</span>(store: ...))
</code></pre><p>with</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> contentView = <span class="hljs-type">HistoryTransceiverView</span>&lt;<span class="hljs-type">ContentView</span>&gt;()
contentView.resume()
window.rootViewController = <span class="hljs-type">UIHostingController</span>(rootView: contentView) 
</code></pre><p>The call to <code>resume()</code> will set up the transceiver and initiate state broadcasting. If you don‚Äôt want to do this at launch, you can gate this call behind a menu item or some other UI element to turn it on.</p><p>And that‚Äôs it. With these changes in place, you can launch both Historian and your app and whenever actions fire, Historian will receive and display those updates. You can browse the list, step through the updates, and the macOS app even allows you to drag and drop state snapshots from and to Historian.</p><h2>Wrapping up</h2><p>As mentioned above, you can find an <a href="https://github.com/finestructure/PFCompArch">example Composable Architecture application on Github</a> and <a href="https://github.com/finestructure/PFCompArch/pull/6">this Pull Request</a> shows you how to integrate Historian with it.</p><p>If you are following the Pointfree.co series and are familiar with their example app ‚ÄúPrime Time‚Äù, you can find the same integration done for their app in <a href="https://github.com/pointfreeco/episode-code-samples/pull/52">this pull request</a>.</p><p>I hope you find this post useful and would love to see what apps you successfully instrument for ‚ÄúState Surfing‚Äù. Please drop me a line and let me know!</p><p>Follow me <a href="https://twitter.com/_sa_s">on twitter</a> to catch announcements about Historian and State Surfing and please <a href="mailto:sas+blog@finestructure.co">get in touch</a> if you have questions, comments, or suggestions.</p></div>
				<span>Tagged with: </span>
				<ul class="tag-list"></ul>
			</article>
		</div>
		<footer>
			<div class="wrapper">
				<div id="container">
					<div id="left-footer"></div>
					<div id="mid-footer"></div>
					<div id="right-footer">
						<p align="right">
							<a href="/feed.rss">RSS feed</a>
						</p>
					</div>
				</div>
			</div>
		</footer>
	</body>
</html>